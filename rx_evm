%% Ricevitore

% ---------- packet 
% 8 bit start sequence 
% 8 bit packet number
% 4 byte data
% 1 byte crc
% 8 bit end sequence 


close all;
%clear;

% Specifiche Adalm Pluto
Mypluto=findPlutoRadio
idTX=append('sn:', Mypluto.SerialNum);

% Definizione Variabili
SamplingRate=1e6;
T_symbol = 1/SamplingRate;   % Tempo di simbolo
fc=2.475e9;
lung_sig = 2000;

cmax=0;
offset=0;

Nsearch = 20;

%sequenze conosciute
seq_start=[1,1,0,1,0,1,0,1];
seq_end=[1,1,1,0,0,0,1,1,];

beta= 0.5; % Fattore di roll-off del filtro
span = 6; % Lunghezza in simboli del filtro
sps = 8;  % Campioni per simbolo (oversampling factor)

% Ricevitore PLuto
rxPluto = sdrrx('Pluto','RadioID',...
    "usb:0",'CenterFrequency',fc,...
    'GainSource','AGC Fast Attack',...
     'Gain',40,...
     'OutputDataType','single',...
     'BasebandSampleRate',SamplingRate,...
     'ShowAdvancedProperties',1,...
     'FrequencyCorrection',100);

 tic;   
[rxWave,rx_meta]=capture(rxPluto,80000);
toc;

rxWave_m=abs(rxWave);

% I campioni raccolti sono ora disponibili in rxWave

%% Grafici Segnale Ricevuto
% this will plot the absolute value of the samples

figure
n1 = (0:length(rxWave)-1)/(lung_sig*sps);
plot(n1,rxWave);
title('Segnale Ricevuto')
grid on;
title('Segnale Ricevuto');
xlabel('Numero Trasmissioni');
ylabel('Valori');
axis("padded");


figure
n1 = (0:length(rxWave)-1)/(lung_sig*sps);
plot(n1,rxWave_m);
grid on;
title('Modulo del Segnale Ricevuto');
xlabel('Numero di Trasmissioni');
ylabel('Valori');
axis("padded");

pause

scatterplot(rxWave);
pause


%% Design del filtro a coseno rialzato

while cmax~=5 && offset<8
      
      rxfilter = comm.RaisedCosineReceiveFilter( ...
      'Shape','Square root', ...
      'RolloffFactor',beta, ...
      'FilterSpanInSymbols',span, ...
      'InputSamplesPerSymbol',sps, ...
      'DecimationFactor',sps,...
      DecimationOffset=offset);
      
      rx_signal=rxfilter(rxWave_m); 
      rxNorm=abs(rx_signal)/max(abs(rx_signal)); %per avere intervallo tra 0 e 1
      

    % Decodifica
      for k=1:length(rxNorm)
          if rxNorm(k)>0.5 %soglia di decisione
              sigdemod(k)=1;
          else 
              sigdemod(k)=0;
          end
      end

    %trovo il primo valore della sequenza
    %lag è l'indice di traslazione della convoluzione
      [cros,i_cros] = xcorr(sigdemod,seq_start);
      
      d=max(cros);
      cmax=round(d);
      offset=offset+1;
end

offset=offset-1;
fprintf('offset di decimazione = %d\n',offset);

figure
%t5=0:1:length(rx_signal)-1;
t5=(0:(length(rx_signal)-1))/(lung_sig);
plot(t5,rx_signal);
title('Segnale Rx Filtrato');
xlabel('Numero di Trasmissioni')
ylabel('Valori')
axis padded
grid on

pause

figure (20)
plot(i_cros,cros)

pause

%clear readData; 
readData = struct; 

readData.packNumber = [];      
readData.data = [];
readData.crcOK = [];
readData.delay = [];
readData.scelto = [];

[i,h,frame]=findDelay(cros,i_cros,sigdemod);
[readData(1).packNumber, readData(1).data, readData(1).crcOK] = unpackMessage(frame);
readData(1).delay = i; 
readData(1).scelto = false;

cros(h:h+63)=0;


for index=2:Nsearch
      %azzera cross per pacchetti successivi 
     [i,h,frame]=findDelay(cros,i_cros,sigdemod);

     readData(index).delay = i;
     readData(index).scelto = false;
     [readData(index).packNumber, readData(index).data, readData(index).crcOK] = unpackMessage(frame);
     cros(h:h+63)=0;
end

           
%trova numero pacchetti totale  
Npack = 0;

for index=(1:Nsearch)
    
    if (readData(index).crcOK == 1 & readData(index).packNumber>Npack)
             Npack = readData(index).packNumber;
    end      
end

in=1;
index = 1;
word = '';

while (index<=Npack)
    
    while (in<=Nsearch)

        if (readData(in).crcOK == 1 & readData(in).packNumber == index)
                
            readData(in).scelto = true;
            word = [ word readData(in).data]; %concatena tutte le parole in base al loro indice 

                index= index + 1;
                in=0;
                  
        end
        in =in +1;

    end
      
end

fprintf('Hai ricevuto:\n %s', word)


Ric = double(rxNorm);
Ric = Ric.';

dist0 = Ric;

for i = 1:length(Ric) 
    dist1(i) = Ric(i) - 1;
end

temp = [dist0; dist1];
temp = abs(temp);
evmtot = min(temp);

evm_pack = [];

for index = 1:Nsearch

    if readData(index).scelto == true
        
        delay = readData(index).delay;
        t = evmtot(delay+1:delay+64);

        evm_pack = [evm_pack t];
    end

end

figure
stem(evm_pack,'filled',Color="#7E2F8E")
title('Error Vector Magnitude');
xlabel('Simboli dei pacchetti usati')
ylabel('Valori')
axis padded


evm_pack_medio = sum(evm_pack)/length(evm_pack);
evmtot_medio = sum(evmtot)/length(evmtot);








%% Funzione che spacchetta messaggio
% installa data aquisition toolbox

% Data una stringa contenente solamente il
% pacchetto su cui bisogna fare l'unpack, 
% ossia seq_start + message + parity +seq_end 

%[readData(1).packNumber, readData(1).data, readData(1).crcOK] = unpackMessage(frame);
function [packetNum, data, crcCheck] = unpackMessage(rawData)
    
    packetNum = rawData(9:16);

    char1 = rawData(17:24);
    char2 = rawData(25:32);
    char3 = rawData(33:40);
    char4 = rawData(41:48);

    dati= rawData(17:48);

     char1= char1 +'0';  
     char1 =char(char1);
     char1=bin2dec(char1);
     char1= char(char1);

      char2= char2 +'0';  
     char2 =char(char2);
     char2=bin2dec(char2);
     char2= char(char2);

      char3= char3 +'0';  
     char3 =char(char3);
     char3=bin2dec(char3);
     char3= char(char3);

      char4= char4 +'0';  
     char4 =char(char4);
     char4=bin2dec(char4);
     char4= char(char4);
    
    data = [char1 char2 char3 char4];

    crc_data = rawData(49:56);
    
    base_crc = [packetNum dati];
    
    crc8 = comm.CRCGenerator('Polynomial','z^8 + z^2 + z + 1');

    t = crc8(base_crc.');
    crc = t(end-8+1:end).';
    
    crcCheck = isequal(crc_data,crc);

    packetNum = packetNum +'0';  
    packetNum =char(packetNum);
    packetNum=bin2dec(packetNum);


end


% [i,h,frame]=findDelay(cros,i_cros,sigdemod);
function [i,h,frame]=findDelay(c,c_lag,sigdemod)

        seq_start=[1,1,0,1,0,1,0,1];
        [m,h] = max(c);
        i = c_lag(h);
        %figure
        % plot(lag_start,c,[i i],[-0.5 1],'r:')
        text(i+100,0.5,['Lag: ' int2str(i)])
        ylabel('c')
        axis tight
        title('Cross-Correlation')
        %s1=sigdemod(i+1:end);
        if i>=(10000-64)  %se il campione è a fine cattura
            i=0;
        end
        frame = sigdemod(i+1:i+64);
        % figure;
        % % plot(frame,'x')
        % hold on
        % % plot(seq_start,'go')
        % xlim([0,20]);
        % hold off
end

